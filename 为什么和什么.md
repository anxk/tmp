# 模块 第 1 部分：为什么和做什么


## 引言

自 Go 语言最初发布以来，有三个关键问题一直困扰着开发人员，而模块的出现则为这三个问题提供了完整的解决方案：

* 能够在 GOPATH 工作区之外使用 Go 代码；
* 能够对依赖项进行版本控制并确定要使用的最兼容版本；
* 能够使用 Go 工具管理本地依赖项；

随着 Go 语言 1.13 版本的发布，这三个问题已经成为了“过去时”。 过去的两年中，Go 语言团队花费了很多精力才让所有人达到这一步。 在本文中，我将重点介绍从 GOPATH 到模块的过渡以及模块所解决的问题。 在此过程中，我将只提供足够的术语，以便您可以更好地了解模块如何在较高的层面上工作。 也许更为重要的是，为什么它们以这样的方式工作。


## GOPATH

使用 GOPATH 在 Go 工作区所在的磁盘上提供物理位置已经为 Go 语言开发人员提供了很好的服务。 不幸的是，对于非 Go 语言开发人员来说，这却是一个瓶颈，因为他们可能需要不时的进行 Go 项目，并且没有设置 Go 工作区。 Go 语言团队想要解决的问题之一是允许将 Go 代码仓库（repo）克隆到磁盘上的任何位置（GOPATH 之外），并使 Go 工具能够定位，构建和测试代码。

图1

![108_figure1.png](https://www.ardanlabs.com/images/goinggo/108_figure1.png)

图 1 显示了 [conf](https://github.com/ardanlabs/conf) 包的 GitHub 仓库。 此仓库表示一个软件包，为处理应用程序中的配置提供支持。 在模块出现之前，如果要使用该包，可以通过 `go get` 在仓库中使用仓库的规范名称克隆仓库副本。 规范名称是远程仓库的根目录和仓库名称的组合。

作为模块出现之前的示例，如果您运行 `go get github.com/ardanlabs/conf`，那么代码将会被复制到磁盘的路径 `$GOPATH/src/github.com/ardanlabs/conf` 处。 多亏有了 GOPATH 并知道仓库的规范名称，所以 Go 工具可以找到代码，而不论开发人员选择将工作区放置在其机器上的位置如何。


## 解决导入

清单 1 
[github.com/ardanlabs/conf/blob/master/conf_test.go](https://www.ardanlabs.com/blog/2019/10/github.com/ardanlabs/conf/blob/master/conf_test.go)

```go
01 package conf_test
02
03 import (
...
10     "github.com/ardanlabs/conf"
...
12 )
```

清单 1 是 `conf` 仓库中 conf_test.go 测试文件 import 部分的部分代码。 当在包名称中使用 `_test` 的约定命名时（如您在第 01 行看到的那样），意味着测试代码与被测试的代码存在于不同的包中，并且测试代码必须像任何外部用户一样导入该包。 您可以在第 10 行看到此测试文件如何使用仓库的规范名导入 `conf` 包。 借助 GOPATH 机制，可以在磁盘上解决此导入问题，并且该工具可以定位，构建和测试代码。

当 GOPATH 不再存在并且文件夹结构与仓库的规范名称不再一致时，这些功能将如何工作？

清单 2
```go
import "github.com/ardanlabs/conf"

// GOPATH模式：磁盘上的物理位置与 GOPATH 匹配
// 和仓库的规范名称。
$GOPATH/src/github.com/ardanlabs/conf


// 模块模式：磁盘上的物理位置不代表
// 仓库的规范名称。
/users/bill/conf
```

清单 2 显示了在所需的任何位置克隆 `conf` 仓库的问题。 当开发人员可以选择将代码克隆到所需的任何位置时，所有将相同导入解析回物理磁盘的信息都消失了。

解决此问题的方法是拥有一个包含仓库规范名称的特殊文件。 该文件在磁盘上的位置用作 GOPATH 的替代，并且在文件内定义了仓库的规范名，无论 Go 代码被克隆到何处，Go 工具都可以解析导入。

决定将这个特殊文件命名为 [go.mod](https://golang.org/cmd/go/#hdr-The_go_mod_file)，并且在文件内定义的仓库的规范名将代表这个称为模块的新实体 。

清单 3
[github.com/ardanlabs/conf/blob/v1.1.0/go.mod](https://www.ardanlabs.com/blog/2019/10/github.com/ardanlabs/conf/blob/v1.1.0/go.mod)

```go
01 module github.com/ardanlabs/conf
02
...
06
```

清单 3 显示了 `conf` 仓库中 `go.mod` 文件的第一行。 该行定义了模块的名称，该模块代表开发人员期望用来引用仓库中任何代码的规范名。 现在，克隆仓库的位置都没有关系，因为 Go 工具可以使用模块文件的位置和模块名称来解析任何内部导入，例如测试文件中的导入。

通过模块的概念，可以将代码克隆到磁盘上的任何位置，下一个要解决的问题是支持将代码捆绑在一起并进行版本控制。


## 捆绑和版本控制

大多数版本控制系统都允许对代码仓库的任意提交点打标签。 这些标签通常用于发布新功能（例如：v1.0.0、v2.3.8 等），并且被认为是不可变的。

图 2

![108_figure2.png](https://www.ardanlabs.com/images/goinggo/108_figure2.png)

图2显示 `conf` 包的作者标记了仓库的三个不同版本。 这些标记的版本遵循 [语义版本控制](https://semver.org/)格式。

使用 VCS 工具，开发人员可以通过引用特定标签将任何特定版本的 `conf` 软件包克隆到磁盘上。 但是，首先要回答几个问题：

* 我应该使用哪个版本的软件包？
* 我怎么知道哪个版本与我正在编写和使用的所有代码兼容？
回答完这两个问题后，您需要回答第三个问题：
* 在哪里克隆仓库，以便 Go 工具可以找到和访问它？

然后情况变得更糟。 您不能在自己的项目中使用 `conf` 软件包的版本，除非您还克隆了 `conf` 所依赖软件包的所有仓库。 这是项目所有传递依赖项的问题。

当在 GOPATH 模式下运行时，解决方案是使用 `go get` 来识别并将所有依赖项的所有仓库克隆到您的 GOPATH 工作空间中。 但是，这并不是一个完美的解决方案，因为 `go get` 只知道如何为每个依赖项克隆并更新来自 `master` 分支的最新代码。 在编写初始代码时，可以从 `master` 分支中为每个依赖项提取代码都可以。 最终，在几个月（或几年）的依赖关系独立发展之后，依赖关系的最新“主”代码可能不再与您的项目兼容。 这是因为您的项目不遵守版本标记，因此任何升级都可能包含重大更改。

当在新的模块模式下运行时，不再需要 `go get` 选项将所有依赖项的仓库克隆到一个定义良好的工作空间中。 另外，您需要找到一种引用每个依赖项的兼容版本的方式，该方式适用于整个项目。 然后，在您的依赖项导入同一包的不同主要版本的情况下，支持在项目中使用同一依赖项的不同主要语义版本。

尽管这些问题的一些解决方案已经以社区开发的工具的形式存在（dep、godep、glide等），但是 Go 需要一个集成的解决方案。 解决方案是重用模块文件，以维护按版本列出的直接和有时间接的依赖关系列表。 然后将任何给定版本的仓库都视为一个不变的代码束。 这个版本化的不可变捆绑包称为模块。


## 完整的解决方案

图 3

![108_figure3.png](https://www.ardanlabs.com/images/goinggo/108_figure3.png)

图3显示了 `repo` 和模块之间的关系。它显示了导入如何引用存储在给定版本的模块内部的包。在这种情况下，版本为 1.1.0 的模块 `conf` 中的代码可以从版本为 0.3.1 的模块 go-cmp 导入软件包 cmp。由于依赖项信息在 conf 模块中列出（通过模块文件），因此 Go 工具可以获取任何模块的选定版本，因此可以成功构建。

一旦有了模块，就会有很多工程机会出现：

* 您可以提供支持（除某些例外），以构建，保留，认证，验证，获取，缓存和重用模块，以供全球 Go 开发人员使用。
* 您可以构建代理服务器来支持不同的 VCS 并提供一些上述支持。
* 您可以验证一个模块（对于任何给定的版本）始终包含已知存在于该模块中的完全相同的代码，而不管它被构建了多少次，从何处获取以及由谁获取。

关于模块所能支持的最好的部分是，Go 团队已经在 Go 的 1.13 版本中设计了很多这种支持。


## 结论

这篇文章试图为理解模块是什么以及 Go 团队如何使用此解决方案奠定基础。还有很多话要说，例如：

* 如何选择要使用的模块的特定版本？
* 模块文件的结构如何，您必须选择哪些选项来控制模块的选择？
* 如何在本地构建，获取和缓存模块以解决导入问题？
* 如何为语义版本控制的社会契约验证模块？
* 在您自己的项目中应如何使用模块以及最佳实践是什么？

在以后的帖子中，我计划提供对这些问题以及更多其他内容的理解。 现在，请确保您了解仓库，包和模块之间的关系。 如有任何疑问，请随时在 Slack 上找到我。 有一个很棒的频道，称为 `#modules`，那里的人们随时可以提供帮助。


## 模块文档
有许多关于 Go 语言的文档，下面是由 Go 语言团队发布的一些文章和视频。

[Modules The Wiki](https://github.com/golang/go/wiki/Modules)  
[1.13 Go 发行说明](https://golang.org/doc/go1.13#modules)  
[Go Blog：启动了模块镜像和校验和数据库](https://blog.golang.org/module-mirror-launch)  
[Go Blog：发布 Go 模块](https://blog.golang.org/publishing-go-modules)  
[Proposal: Secure the Public Go Module Ecosystem](https://go.googlesource.com/proposal/+/master/design/25530-sumdb.md)  
[GopherCon 2019: Katie Hockman - Go Module Proxy: Life of a Query](https://www.youtube.com/watch?v=KqTySYYhPUE)  


---

via: https://www.ardanlabs.com/blog/2019/10/modules-01-why-and-what.html

作者：[William Kennedy](https://www.ardanlabs.com/)
译者：[anxk](https://github.com/anxk)
校对：[校对者ID](https://github.com/校对者ID)

本文由 [GCTT](https://github.com/studygolang/GCTT) 原创编译，[Go 中文网](https://studygolang.com/) 荣誉推出
